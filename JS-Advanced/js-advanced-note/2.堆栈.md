### ECStack 执行环境栈 [栈内存 Stack]

1.供代码执行 2.存储原始值类型的值

- EC(G): 全局执行上下文
- VO(G): 全局变量对象[存储全局上下文中声明的变量]
- window —————————————— 0x000

浏览器从计算机内存中分配出来的内存

### 堆内存 Heap

1. 存储对象类型值
2. GO：全局对象[堆内存开辟的空间]
3. 16 进制的内存地址：0x000
4. 存储浏览器内置的 API

- setTimeout
- setInterval
- requestAnimationFrame
- JSON

### 特殊性:

```
在 "全局" 上下文中, 基于 var/function 声明的变量,没有存放在 VO(G) 中,
而是存储在 GO 中
只有基于 let/const 声明的变量是存储在VO(G)中
```

### 变量提升

```
在当前上下文代码执行之前，浏览器首先会把所有带var/function
关键字的进行提前声明或者定义,[let/const不存在变量提升]

带var的只是提前声明, 带function的会声明+定义(赋值)

声明: declare  例如：var a;
定义: defined  例如: a=12;
```

### let/const

```
let a = 10;
1. 先创建10, 对象也是先创建值
2. 声明变量a, 排除变量提升
3. 赋值[指针指向过程]
```

```js
var a = {
  n: 1,
};
var b = a;
a.x = a = {
  n: 2,
};
console.log(a.x);
console.log(b);
```

### 对象创建值的操作

```
1. 在HEAP中分配一块内存，有个16进制地址
2. 把对象中的键值对一次存储到这个空间中
3. 把内存的地址赋值给对应的变量/属性关联
```

0x001: {n:1}
0x002: {n:2}

a.x = a = 0x002
a = b = 10
(1). b = 10
(2). a = b [a = 10]
```
正常情况下都是连等赋值, 是从右到左处理的, 但是会出现某个操作的优先级较高, 此时优先级较高的先处理
```


